// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/// @title IGroth16Verifier
/// @notice Common interface for snarkjs-generated Groth16 verifier contracts.
///         Each circuit has a different pubSignals array size, so we use
///         a raw staticcall with abi-encoded data.
interface IGroth16Verifier {
    function verifyProof(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[] calldata _pubSignals
    ) external view returns (bool);
}

/// @title ZKVerifier
/// @notice Delegates ZK proof verification to deployed Groth16 verifier contracts
///         generated by snarkjs from circom circuits.
/// @dev The audit verifier expects 52 public signals (10 signals * 5 fields + 2 score fields).
///      The track record verifier expects 106 public signals (20 signals * 5 fields + 6 aggregate fields).
///      When no verifier is set, verification returns true (placeholder mode).
contract ZKVerifier is Ownable {
    /// @notice Address of the deployed Groth16AuditVerifier contract
    address public auditVerifier;

    /// @notice Address of the deployed Groth16TrackRecordVerifier contract
    address public trackRecordVerifier;

    event AuditVerifierUpdated(address indexed verifier);
    event TrackRecordVerifierUpdated(address indexed verifier);

    error ZeroAddress();
    error VerificationCallFailed();

    /// @param _owner Address that will own this contract
    constructor(address _owner) Ownable(_owner) {}

    /// @notice Set the audit proof verifier contract address
    /// @param _verifier Address of the deployed Groth16AuditVerifier
    function setAuditVerifier(address _verifier) external onlyOwner {
        if (_verifier == address(0)) revert ZeroAddress();
        auditVerifier = _verifier;
        emit AuditVerifierUpdated(_verifier);
    }

    /// @notice Set the track record proof verifier contract address
    /// @param _verifier Address of the deployed Groth16TrackRecordVerifier
    function setTrackRecordVerifier(address _verifier) external onlyOwner {
        if (_verifier == address(0)) revert ZeroAddress();
        trackRecordVerifier = _verifier;
        emit TrackRecordVerifierUpdated(_verifier);
    }

    /// @notice Verify a Groth16 proof of audit settlement (Quality Score)
    /// @param _pA Proof element A (G1 point)
    /// @param _pB Proof element B (G2 point)
    /// @param _pC Proof element C (G1 point)
    /// @param _pubSignals Public signals array (52 elements for audit proof)
    /// @return valid True if the proof verifies
    function verifyAuditProof(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[52] calldata _pubSignals
    ) external view returns (bool valid) {
        if (auditVerifier == address(0)) return true; // Placeholder mode

        (bool success, bytes memory result) = auditVerifier.staticcall(
            abi.encodeWithSignature(
                "verifyProof(uint256[2],uint256[2][2],uint256[2],uint256[52])",
                _pA, _pB, _pC, _pubSignals
            )
        );
        if (!success || result.length < 32) revert VerificationCallFailed();
        return abi.decode(result, (bool));
    }

    /// @notice Verify a Groth16 proof of track record statistics
    /// @param _pA Proof element A (G1 point)
    /// @param _pB Proof element B (G2 point)
    /// @param _pC Proof element C (G1 point)
    /// @param _pubSignals Public signals array (106 elements for track record proof)
    /// @return valid True if the proof verifies
    function verifyTrackRecordProof(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[106] calldata _pubSignals
    ) external view returns (bool valid) {
        if (trackRecordVerifier == address(0)) return true; // Placeholder mode

        (bool success, bytes memory result) = trackRecordVerifier.staticcall(
            abi.encodeWithSignature(
                "verifyProof(uint256[2],uint256[2][2],uint256[2],uint256[106])",
                _pA, _pB, _pC, _pubSignals
            )
        );
        if (!success || result.length < 32) revert VerificationCallFailed();
        return abi.decode(result, (bool));
    }
}
