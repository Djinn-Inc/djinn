"""MPC session coordination for multi-validator signal availability checks.

In production, multiple validators participate in the MPC protocol.
This module manages MPC sessions:
- A coordinator (any validator) initiates a session
- Each validator computes local contributions
- Validators exchange Beaver triple multiplication messages
- The coordinator aggregates and opens the final result

Transport is HTTP â€” validators call each other's /v1/mpc/* endpoints.
"""

from __future__ import annotations

import secrets
import time
from dataclasses import dataclass, field
from enum import Enum, auto

import structlog

from djinn_validator.core.mpc import (
    BeaverTriple,
    MPCResult,
    Round1Message,
    SecureMPCSession,
    _split_secret_at_points,
    generate_beaver_triples,
    secure_check_availability,
)
from djinn_validator.utils.crypto import BN254_PRIME, Share

log = structlog.get_logger()


class SessionStatus(Enum):
    INITIATED = auto()
    ROUND1_COLLECTING = auto()
    COMPUTING = auto()
    COMPLETE = auto()
    FAILED = auto()
    EXPIRED = auto()


@dataclass
class MPCSessionState:
    """State for a multi-validator MPC session."""

    session_id: str
    signal_id: str
    available_indices: list[int]
    coordinator_x: int  # x-coordinate of the coordinator validator
    participant_xs: list[int]  # x-coordinates of all participants
    threshold: int
    status: SessionStatus = SessionStatus.INITIATED
    created_at: float = field(default_factory=time.time)

    # Beaver triples (generated by coordinator, distributed to participants)
    triples: list[BeaverTriple] = field(default_factory=list)

    # Round 1 messages collected from participants (gate_idx -> list of messages)
    round1_messages: dict[int, list[Round1Message]] = field(default_factory=dict)

    # Final result
    result: MPCResult | None = None


class MPCCoordinator:
    """Manages MPC sessions for this validator.

    Each purchase triggers an MPC session. The coordinator:
    1. Generates Beaver triples
    2. Distributes triple shares to participants
    3. Collects Round 1 messages
    4. Computes the result
    """

    SESSION_TTL = 120  # seconds

    def __init__(self) -> None:
        self._sessions: dict[str, MPCSessionState] = {}

    def create_session(
        self,
        signal_id: str,
        available_indices: list[int],
        coordinator_x: int,
        participant_xs: list[int],
        threshold: int = 7,
    ) -> MPCSessionState:
        """Create a new MPC session as coordinator."""
        session_id = f"mpc-{signal_id}-{secrets.token_hex(8)}"

        # Generate Beaver triples for the computation
        n_mults = max(len(available_indices), 1)
        triples = generate_beaver_triples(
            count=n_mults,
            n=len(participant_xs),
            k=threshold,
            x_coords=sorted(participant_xs),
        )

        session = MPCSessionState(
            session_id=session_id,
            signal_id=signal_id,
            available_indices=available_indices,
            coordinator_x=coordinator_x,
            participant_xs=sorted(participant_xs),
            threshold=threshold,
            triples=triples,
            status=SessionStatus.ROUND1_COLLECTING,
        )

        self._sessions[session_id] = session
        log.info(
            "mpc_session_created",
            session_id=session_id,
            signal_id=signal_id,
            participants=len(participant_xs),
        )
        return session

    def get_session(self, session_id: str) -> MPCSessionState | None:
        """Retrieve a session by ID."""
        session = self._sessions.get(session_id)
        if session and time.time() - session.created_at > self.SESSION_TTL:
            session.status = SessionStatus.EXPIRED
        return session

    def get_triple_shares_for_participant(
        self,
        session_id: str,
        participant_x: int,
    ) -> list[dict[str, int]] | None:
        """Extract this participant's triple shares from the session.

        Returns a list of {a, b, c} share values for each triple.
        """
        session = self._sessions.get(session_id)
        if session is None:
            return None

        shares_out = []
        for triple in session.triples:
            a_val = next((s.y for s in triple.a_shares if s.x == participant_x), None)
            b_val = next((s.y for s in triple.b_shares if s.x == participant_x), None)
            c_val = next((s.y for s in triple.c_shares if s.x == participant_x), None)
            if a_val is None or b_val is None or c_val is None:
                log.error(
                    "triple_share_not_found",
                    session_id=session_id,
                    participant_x=participant_x,
                )
                return None
            shares_out.append({"a": a_val, "b": b_val, "c": c_val})
        return shares_out

    def submit_round1(
        self,
        session_id: str,
        gate_idx: int,
        message: Round1Message,
    ) -> bool:
        """Submit a Round 1 message for a specific multiplication gate."""
        session = self._sessions.get(session_id)
        if session is None or session.status != SessionStatus.ROUND1_COLLECTING:
            return False

        if gate_idx not in session.round1_messages:
            session.round1_messages[gate_idx] = []

        # Avoid duplicate submissions
        existing_xs = {m.validator_x for m in session.round1_messages[gate_idx]}
        if message.validator_x in existing_xs:
            return True  # Already submitted

        session.round1_messages[gate_idx].append(message)
        return True

    def is_round_complete(self, session_id: str) -> bool:
        """Check if all participants have submitted Round 1 for all gates."""
        session = self._sessions.get(session_id)
        if session is None:
            return False

        n_gates = max(len(session.available_indices), 1)
        n_participants = len(session.participant_xs)

        for gate_idx in range(n_gates):
            msgs = session.round1_messages.get(gate_idx, [])
            if len(msgs) < n_participants:
                return False
        return True

    def compute_result_with_shares(
        self,
        session_id: str,
        shares: list[Share],
    ) -> MPCResult | None:
        """Run the full MPC using the secure protocol.

        This is the production path: the coordinator has collected all shares
        and runs the secure computation. In a truly distributed system, each
        validator would hold only their own share and the computation would
        happen through message passing. This method simulates the full protocol
        locally for correctness, using the collected shares.

        For the distributed path, use submit_round1() + finalize().
        """
        session = self._sessions.get(session_id)
        if session is None:
            return None

        result = secure_check_availability(
            shares=shares,
            available_indices=set(session.available_indices),
            threshold=session.threshold,
        )

        session.result = result
        session.status = SessionStatus.COMPLETE
        return result

    def cleanup_expired(self) -> int:
        """Remove expired sessions. Returns count of removed sessions."""
        now = time.time()
        expired = [
            sid for sid, s in self._sessions.items()
            if now - s.created_at > self.SESSION_TTL
        ]
        for sid in expired:
            del self._sessions[sid]
        return len(expired)

    @property
    def active_session_count(self) -> int:
        return sum(
            1 for s in self._sessions.values()
            if s.status not in (SessionStatus.COMPLETE, SessionStatus.EXPIRED, SessionStatus.FAILED)
        )
