"""MPC session coordination for multi-validator signal availability checks.

In production, multiple validators participate in the MPC protocol.
This module manages MPC sessions:
- A coordinator (any validator) initiates a session
- Each validator computes local contributions
- Validators exchange Beaver triple multiplication messages
- The coordinator aggregates and opens the final result

Transport is HTTP — validators call each other's /v1/mpc/* endpoints.
"""

from __future__ import annotations

import secrets
import threading
import time
from dataclasses import dataclass, field
from enum import Enum, auto

import structlog

from djinn_validator.core.mpc import (
    BeaverTriple,
    MPCResult,
    Round1Message,
    SecureMPCSession,
    _split_secret_at_points,
    generate_beaver_triples,
    secure_check_availability,
)
from djinn_validator.utils.crypto import BN254_PRIME, Share

log = structlog.get_logger()


class SessionStatus(Enum):
    INITIATED = auto()
    ROUND1_COLLECTING = auto()
    COMPUTING = auto()
    COMPLETE = auto()
    FAILED = auto()
    EXPIRED = auto()


@dataclass
class MPCSessionState:
    """State for a multi-validator MPC session."""

    session_id: str
    signal_id: str
    available_indices: list[int]
    coordinator_x: int  # x-coordinate of the coordinator validator
    participant_xs: list[int]  # x-coordinates of all participants
    threshold: int
    status: SessionStatus = SessionStatus.INITIATED
    created_at: float = field(default_factory=time.monotonic)

    # Beaver triples (generated by coordinator, distributed to participants)
    triples: list[BeaverTriple] = field(default_factory=list)

    # Round 1 messages collected from participants (gate_idx -> list of messages)
    round1_messages: dict[int, list[Round1Message]] = field(default_factory=dict)

    # Final result
    result: MPCResult | None = None


class MPCCoordinator:
    """Manages MPC sessions for this validator.

    Each purchase triggers an MPC session. The coordinator:
    1. Generates Beaver triples
    2. Distributes triple shares to participants
    3. Collects Round 1 messages
    4. Computes the result
    """

    SESSION_TTL = 120  # seconds
    MAX_SESSIONS = 500

    def __init__(self) -> None:
        self._sessions: dict[str, MPCSessionState] = {}
        self._lock = threading.Lock()

    def create_session(
        self,
        signal_id: str,
        available_indices: list[int],
        coordinator_x: int,
        participant_xs: list[int],
        threshold: int = 7,
    ) -> MPCSessionState:
        """Create a new MPC session as coordinator."""
        session_id = f"mpc-{signal_id}-{secrets.token_hex(8)}"

        # Generate Beaver triples for the computation
        n_mults = max(len(available_indices), 1)
        triples = generate_beaver_triples(
            count=n_mults,
            n=len(participant_xs),
            k=threshold,
            x_coords=sorted(participant_xs),
        )

        session = MPCSessionState(
            session_id=session_id,
            signal_id=signal_id,
            available_indices=available_indices,
            coordinator_x=coordinator_x,
            participant_xs=sorted(participant_xs),
            threshold=threshold,
            triples=triples,
            status=SessionStatus.ROUND1_COLLECTING,
        )

        with self._lock:
            if len(self._sessions) >= self.MAX_SESSIONS:
                # Evict oldest expired first, then oldest overall
                self._evict_one_locked()
            self._sessions[session_id] = session
        log.info(
            "mpc_session_created",
            session_id=session_id,
            signal_id=signal_id,
            participants=len(participant_xs),
        )
        return session

    def get_session(self, session_id: str) -> MPCSessionState | None:
        """Retrieve a session by ID. Returns None for expired sessions."""
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None:
                return None
            if time.monotonic() - session.created_at > self.SESSION_TTL:
                session.status = SessionStatus.EXPIRED
                del self._sessions[session_id]
                log.info("mpc_session_expired", session_id=session_id)
                return None
            return session

    def get_triple_shares_for_participant(
        self,
        session_id: str,
        participant_x: int,
    ) -> list[dict[str, int]] | None:
        """Extract this participant's triple shares from the session.

        Returns a list of {a, b, c} share values for each triple.
        """
        with self._lock:
            session = self._sessions.get(session_id)
        if session is None:
            return None

        shares_out = []
        for triple in session.triples:
            a_val = next((s.y for s in triple.a_shares if s.x == participant_x), None)
            b_val = next((s.y for s in triple.b_shares if s.x == participant_x), None)
            c_val = next((s.y for s in triple.c_shares if s.x == participant_x), None)
            if a_val is None or b_val is None or c_val is None:
                log.error(
                    "triple_share_not_found",
                    session_id=session_id,
                    participant_x=participant_x,
                )
                return None
            shares_out.append({"a": a_val, "b": b_val, "c": c_val})
        return shares_out

    def submit_round1(
        self,
        session_id: str,
        gate_idx: int,
        message: Round1Message,
    ) -> bool:
        """Submit a Round 1 message for a specific multiplication gate."""
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None or session.status != SessionStatus.ROUND1_COLLECTING:
                return False

            if gate_idx not in session.round1_messages:
                session.round1_messages[gate_idx] = []

            # Avoid duplicate submissions
            existing_xs = {m.validator_x for m in session.round1_messages[gate_idx]}
            if message.validator_x in existing_xs:
                return True  # Already submitted

            session.round1_messages[gate_idx].append(message)
            return True

    def is_round_complete(self, session_id: str) -> bool:
        """Check if all participants have submitted Round 1 for all gates."""
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None:
                return False

            n_gates = max(len(session.available_indices), 1)
            n_participants = len(session.participant_xs)

            for gate_idx in range(n_gates):
                msgs = session.round1_messages.get(gate_idx, [])
                if len(msgs) < n_participants:
                    return False
            return True

    def compute_result_with_shares(
        self,
        session_id: str,
        shares: list[Share],
    ) -> MPCResult | None:
        """Run the full MPC using the secure protocol.

        This is the production path: the coordinator has collected all shares
        and runs the secure computation. In a truly distributed system, each
        validator would hold only their own share and the computation would
        happen through message passing. This method simulates the full protocol
        locally for correctness, using the collected shares.

        For the distributed path, use submit_round1() + finalize().
        """
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None:
                return None

        result = secure_check_availability(
            shares=shares,
            available_indices=set(session.available_indices),
            threshold=session.threshold,
        )

        with self._lock:
            session.result = result
            session.status = SessionStatus.COMPLETE
        return result

    def _evict_one_locked(self) -> None:
        """Evict one session to make room. Must be called with _lock held."""
        now = time.monotonic()
        # Prefer evicting expired sessions
        for sid, s in list(self._sessions.items()):
            if now - s.created_at > self.SESSION_TTL:
                del self._sessions[sid]
                log.info("mpc_session_evicted_expired", session_id=sid)
                return
        # No expired sessions — evict the oldest
        if self._sessions:
            oldest_sid = min(self._sessions, key=lambda sid: self._sessions[sid].created_at)
            del self._sessions[oldest_sid]
            log.warning("mpc_session_evicted_oldest", session_id=oldest_sid)

    def replace_session_id(self, old_id: str, new_id: str) -> bool:
        """Atomically rename a session's ID. Used by participants to match coordinator's ID.

        Returns True if the rename succeeded, False if old_id not found or new_id already exists.
        """
        with self._lock:
            session = self._sessions.get(old_id)
            if session is None:
                return False
            if new_id in self._sessions:
                return False
            del self._sessions[old_id]
            session.session_id = new_id
            self._sessions[new_id] = session
            return True

    def set_result(self, session_id: str, result: MPCResult) -> bool:
        """Set the final result on a session. Used by participants receiving coordinator's broadcast.

        Returns True if the result was set, False if the session was not found.
        """
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None:
                return False
            session.result = result
            session.status = SessionStatus.COMPLETE
            return True

    def cleanup_expired(self) -> int:
        """Remove expired sessions. Returns count of removed sessions."""
        now = time.monotonic()
        with self._lock:
            expired = [
                sid for sid, s in self._sessions.items()
                if now - s.created_at > self.SESSION_TTL
            ]
            for sid in expired:
                del self._sessions[sid]
        return len(expired)

    @property
    def active_session_count(self) -> int:
        with self._lock:
            return sum(
                1 for s in self._sessions.values()
                if s.status not in (SessionStatus.COMPLETE, SessionStatus.EXPIRED, SessionStatus.FAILED)
            )
