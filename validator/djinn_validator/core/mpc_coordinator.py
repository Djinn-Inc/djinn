"""MPC session coordination for multi-validator signal availability checks.

In production, multiple validators participate in the MPC protocol.
This module manages MPC sessions:
- A coordinator (any validator) initiates a session
- Each validator computes local contributions
- Validators exchange Beaver triple multiplication messages
- The coordinator aggregates and opens the final result

Transport is HTTP — validators call each other's /v1/mpc/* endpoints.
"""

from __future__ import annotations

import secrets
import threading
import time
from dataclasses import dataclass, field
from enum import Enum, auto

import structlog

from djinn_validator.core.mpc import (
    BeaverTriple,
    MPCResult,
    Round1Message,
    generate_beaver_triples,
    generate_ot_beaver_triples,
    secure_check_availability,
)
from djinn_validator.core.spdz import (
    AuthenticatedBeaverTriple,
    MACKeyShare,
    generate_authenticated_triples,
    generate_mac_key,
)
from djinn_validator.utils.crypto import Share

log = structlog.get_logger()


class SessionStatus(Enum):
    INITIATED = auto()
    ROUND1_COLLECTING = auto()
    COMPUTING = auto()
    COMPLETE = auto()
    FAILED = auto()
    EXPIRED = auto()


@dataclass
class MPCSessionState:
    """State for a multi-validator MPC session."""

    session_id: str
    signal_id: str
    available_indices: list[int]
    coordinator_x: int  # x-coordinate of the coordinator validator
    participant_xs: list[int]  # x-coordinates of all participants
    threshold: int
    status: SessionStatus = SessionStatus.INITIATED
    created_at: float = field(default_factory=time.monotonic)

    # Beaver triples (generated by coordinator, distributed to participants)
    triples: list[BeaverTriple] = field(default_factory=list)

    # SPDZ authenticated triples (used when use_authenticated_mpc=True)
    authenticated_triples: list[AuthenticatedBeaverTriple] = field(default_factory=list)
    mac_key_shares: list[MACKeyShare] = field(default_factory=list)
    mac_alpha: int = 0  # Global MAC key (coordinator only, for triple generation)

    # Round 1 messages collected from participants (gate_idx -> list of messages)
    round1_messages: dict[int, list[Round1Message]] = field(default_factory=dict)

    # Final result
    result: MPCResult | None = None

    @property
    def is_authenticated(self) -> bool:
        return len(self.authenticated_triples) > 0


class MPCCoordinator:
    """Manages MPC sessions for this validator.

    Each purchase triggers an MPC session. The coordinator:
    1. Generates Beaver triples
    2. Distributes triple shares to participants
    3. Collects Round 1 messages
    4. Computes the result
    """

    SESSION_TTL = 120  # seconds
    MAX_SESSIONS = 500

    def __init__(self) -> None:
        self._sessions: dict[str, MPCSessionState] = {}
        # threading.Lock (not asyncio.Lock) is intentional: all critical sections
        # are sub-millisecond dict ops so they won't block the event loop, and
        # threading.Lock is safe to use from both sync and async callers.
        self._lock = threading.Lock()

    def create_session(
        self,
        signal_id: str,
        available_indices: list[int],
        coordinator_x: int,
        participant_xs: list[int],
        threshold: int = 7,
        use_ot: bool | None = None,
        use_authenticated: bool | None = None,
        pre_generated_triples: list[BeaverTriple] | None = None,
    ) -> MPCSessionState:
        """Create a new MPC session as coordinator.

        Args:
            use_ot: If True, use OT-based triple generation (no trusted dealer).
                    If None (default), uses OT when >= 2 participants, otherwise
                    falls back to trusted dealer for single-participant mode.
            use_authenticated: If True, generate SPDZ authenticated triples with
                    MAC verification for malicious security. If None (default),
                    reads USE_AUTHENTICATED_MPC env var.
            pre_generated_triples: If provided, skip triple generation and use
                    these pre-computed triples (e.g., from distributed OT).
        """
        import os

        session_id = f"mpc-{signal_id}-{secrets.token_hex(8)}"

        n_mults = max(len(available_indices), 1)
        sorted_xs = sorted(participant_xs)

        # Determine authentication mode
        if use_authenticated is None:
            use_authenticated = os.getenv("USE_AUTHENTICATED_MPC", "").lower() in ("1", "true", "yes")

        # Use OT-based triples when multiple participants are available.
        # Single-participant mode uses trusted dealer (no OT possible with 1 party).
        should_use_ot = use_ot if use_ot is not None else len(participant_xs) >= 2

        authenticated_triples: list[AuthenticatedBeaverTriple] = []
        mac_key_shares: list[MACKeyShare] = []
        mac_alpha: int = 0
        triples: list[BeaverTriple] = []

        if pre_generated_triples is not None:
            triples = pre_generated_triples
            log.info(
                "beaver_triples_generated",
                method="network_ot",
                count=len(triples),
                participants=len(participant_xs),
            )
        elif use_authenticated:
            # Generate SPDZ authenticated triples with MAC key
            mac_alpha, mac_key_shares = generate_mac_key(sorted_xs, threshold)
            # Tree multiplication uses n_mults triples but we add 1 for r*factor[0]
            n_auth_triples = n_mults + 1 if n_mults > 1 else n_mults
            authenticated_triples = generate_authenticated_triples(
                count=n_auth_triples,
                alpha=mac_alpha,
                x_coords=sorted_xs,
                threshold=threshold,
            )
            log.info(
                "beaver_triples_generated",
                method="authenticated_spdz",
                count=n_auth_triples,
                participants=len(participant_xs),
            )
        elif should_use_ot and len(participant_xs) >= 2:
            triples = generate_ot_beaver_triples(
                count=n_mults,
                n=len(participant_xs),
                k=threshold,
                x_coords=sorted_xs,
                party_ids=sorted_xs,
            )
            log.info(
                "beaver_triples_generated",
                method="ot",
                count=n_mults,
                participants=len(participant_xs),
            )
        else:
            triples = generate_beaver_triples(
                count=n_mults,
                n=len(participant_xs),
                k=threshold,
                x_coords=sorted_xs,
            )
            log.info(
                "beaver_triples_generated",
                method="trusted_dealer",
                count=n_mults,
                participants=len(participant_xs),
            )

        session = MPCSessionState(
            session_id=session_id,
            signal_id=signal_id,
            available_indices=available_indices,
            coordinator_x=coordinator_x,
            participant_xs=sorted(participant_xs),
            threshold=threshold,
            triples=triples,
            authenticated_triples=authenticated_triples,
            mac_key_shares=mac_key_shares,
            mac_alpha=mac_alpha,
            status=SessionStatus.ROUND1_COLLECTING,
        )

        with self._lock:
            if len(self._sessions) >= self.MAX_SESSIONS:
                self._evict_one_locked()
            self._sessions[session_id] = session
        log.info(
            "mpc_session_created",
            session_id=session_id,
            signal_id=signal_id,
            participants=len(participant_xs),
            authenticated=session.is_authenticated,
        )
        return session

    def get_session(self, session_id: str) -> MPCSessionState | None:
        """Retrieve a session by ID. Returns None for expired sessions."""
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None:
                return None
            if time.monotonic() - session.created_at > self.SESSION_TTL:
                session.status = SessionStatus.EXPIRED
                del self._sessions[session_id]
                log.info("mpc_session_expired", session_id=session_id)
                return None
            return session

    def get_triple_shares_for_participant(
        self,
        session_id: str,
        participant_x: int,
    ) -> list[dict[str, int]] | None:
        """Extract this participant's triple shares from the session.

        Returns a list of {a, b, c} share values for each triple.
        For authenticated sessions, use get_authenticated_triple_shares instead.
        """
        with self._lock:
            session = self._sessions.get(session_id)
        if session is None:
            return None

        shares_out = []
        for triple in session.triples:
            a_val = next((s.y for s in triple.a_shares if s.x == participant_x), None)
            b_val = next((s.y for s in triple.b_shares if s.x == participant_x), None)
            c_val = next((s.y for s in triple.c_shares if s.x == participant_x), None)
            if a_val is None or b_val is None or c_val is None:
                log.error(
                    "triple_share_not_found",
                    session_id=session_id,
                    participant_x=participant_x,
                )
                return None
            shares_out.append({"a": a_val, "b": b_val, "c": c_val})
        return shares_out

    def purge_peer_triple_shares(
        self,
        session_id: str,
        coordinator_x: int,
    ) -> None:
        """Remove all triple shares except the coordinator's own.

        Called after distributing shares to peers. This ensures the coordinator
        can never access peer triple shares again — enforcing the secrecy
        guarantee that no single validator can reconstruct intermediate values.
        """
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None:
                return
            # Rebuild each triple keeping only the coordinator's share
            purged_triples = []
            for triple in session.triples:
                purged_triples.append(BeaverTriple(
                    a_shares=tuple(s for s in triple.a_shares if s.x == coordinator_x),
                    b_shares=tuple(s for s in triple.b_shares if s.x == coordinator_x),
                    c_shares=tuple(s for s in triple.c_shares if s.x == coordinator_x),
                ))
            session.triples = purged_triples
            log.info(
                "peer_triple_shares_purged",
                session_id=session_id,
                coordinator_x=coordinator_x,
            )

    def get_authenticated_triple_shares(
        self,
        session_id: str,
        participant_x: int,
    ) -> list[dict[str, dict[str, int]]] | None:
        """Extract authenticated triple shares for a participant.

        Returns list of {a: {y, mac}, b: {y, mac}, c: {y, mac}} for each triple.
        """
        with self._lock:
            session = self._sessions.get(session_id)
        if session is None:
            return None

        shares_out = []
        for triple in session.authenticated_triples:
            a_s = next((s for s in triple.a_shares if s.x == participant_x), None)
            b_s = next((s for s in triple.b_shares if s.x == participant_x), None)
            c_s = next((s for s in triple.c_shares if s.x == participant_x), None)
            if a_s is None or b_s is None or c_s is None:
                log.error(
                    "authenticated_triple_share_not_found",
                    session_id=session_id,
                    participant_x=participant_x,
                )
                return None
            shares_out.append(
                {
                    "a": {"y": a_s.y, "mac": a_s.mac},
                    "b": {"y": b_s.y, "mac": b_s.mac},
                    "c": {"y": c_s.y, "mac": c_s.mac},
                }
            )
        return shares_out

    def get_mac_key_share(
        self,
        session_id: str,
        participant_x: int,
    ) -> MACKeyShare | None:
        """Get a participant's MAC key share for an authenticated session."""
        with self._lock:
            session = self._sessions.get(session_id)
        if session is None:
            return None
        for mk in session.mac_key_shares:
            if mk.x == participant_x:
                return mk
        return None

    def submit_round1(
        self,
        session_id: str,
        gate_idx: int,
        message: Round1Message,
    ) -> bool:
        """Submit a Round 1 message for a specific multiplication gate."""
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None or session.status != SessionStatus.ROUND1_COLLECTING:
                return False

            if gate_idx not in session.round1_messages:
                session.round1_messages[gate_idx] = []

            # Avoid duplicate submissions
            existing_xs = {m.validator_x for m in session.round1_messages[gate_idx]}
            if message.validator_x in existing_xs:
                return True  # Already submitted

            session.round1_messages[gate_idx].append(message)
            return True

    def is_round_complete(self, session_id: str) -> bool:
        """Check if all participants have submitted Round 1 for all gates."""
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None:
                return False

            n_gates = max(len(session.available_indices), 1)
            n_participants = len(session.participant_xs)

            for gate_idx in range(n_gates):
                msgs = session.round1_messages.get(gate_idx, [])
                if len(msgs) < n_participants:
                    return False
            return True

    def compute_result_with_shares(
        self,
        session_id: str,
        shares: list[Share],
    ) -> MPCResult | None:
        """Run the full MPC using the secure protocol.

        This is the production path: the coordinator has collected all shares
        and runs the secure computation. In a truly distributed system, each
        validator would hold only their own share and the computation would
        happen through message passing. This method simulates the full protocol
        locally for correctness, using the collected shares.

        For the distributed path, use submit_round1() + finalize().
        """
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None:
                return None

        result = secure_check_availability(
            shares=shares,
            available_indices=set(session.available_indices),
            threshold=session.threshold,
        )

        with self._lock:
            session.result = result
            session.status = SessionStatus.COMPLETE
        return result

    def _evict_one_locked(self) -> None:
        """Evict one session to make room. Must be called with _lock held."""
        now = time.monotonic()
        # Prefer evicting expired sessions
        for sid, s in list(self._sessions.items()):
            if now - s.created_at > self.SESSION_TTL:
                del self._sessions[sid]
                log.info("mpc_session_evicted_expired", session_id=sid)
                return
        # No expired sessions — evict the oldest
        if self._sessions:
            oldest_sid = min(self._sessions, key=lambda sid: self._sessions[sid].created_at)
            del self._sessions[oldest_sid]
            log.warning("mpc_session_evicted_oldest", session_id=oldest_sid)

    def replace_session_id(self, old_id: str, new_id: str) -> bool:
        """Atomically rename a session's ID. Used by participants to match coordinator's ID.

        Returns True if the rename succeeded, False if old_id not found or new_id already exists.
        """
        with self._lock:
            session = self._sessions.get(old_id)
            if session is None:
                return False
            if new_id in self._sessions:
                return False
            del self._sessions[old_id]
            session.session_id = new_id
            self._sessions[new_id] = session
            return True

    def set_result(self, session_id: str, result: MPCResult) -> bool:
        """Set the final result on a session. Used by participants receiving coordinator's broadcast.

        Returns True if the result was set, False if the session was not found.
        """
        with self._lock:
            session = self._sessions.get(session_id)
            if session is None:
                return False
            session.result = result
            session.status = SessionStatus.COMPLETE
            return True

    def cleanup_expired(self) -> int:
        """Remove expired sessions. Returns count of removed sessions."""
        now = time.monotonic()
        with self._lock:
            expired = [sid for sid, s in self._sessions.items() if now - s.created_at > self.SESSION_TTL]
            for sid in expired:
                del self._sessions[sid]
        return len(expired)

    @property
    def active_session_count(self) -> int:
        with self._lock:
            return sum(
                1
                for s in self._sessions.values()
                if s.status not in (SessionStatus.COMPLETE, SessionStatus.EXPIRED, SessionStatus.FAILED)
            )
